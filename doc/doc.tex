\input{tex/texPreamble}
\title{Documentation for matrix2latex}

\begin{document}
\maketitle
Takes a python matrix or nested list and converts to a LaTeX table or matrix.
Author: ob@cakebox.net, inspired by the work of koehler@in.tum.de who has written
a similar package for matlab
\url{http://www.mathworks.com/matlabcentral/fileexchange/4894-matrix2latex}

This software is published under the GNU GPL, by the free software
foundation. For further reading see: 
\url{http://www.gnu.org/licenses/licenses.html#GPL}

\section{TODO}
\begin{itemize}
\item Provide installation.
\item Remove dependency on numpy (might be more portable to other systems)
and will allow for more flexible input (for instance non-rectangular).
\item Complete test suite.
\item Improve error handling by fixing errors instead of crashing.
\item Clean the preamble for this documentation.
\item Code is given in all kinds of fonts in this document. Fix!
\end{itemize}

\section{Installation}
The following packages and definitions are recommended in the latex preamble 
\begin{verbatim}
% scientific notation, 1\e{9} will print as 1x10^9
\providecommand{\e}[1]{\ensuremath{\times 10^{#1}}}
\usepackage{amsmath} % needed for pmatrix
\usepackage{booktabs} % Fancy tables
...
\begin{document}
...
\end{verbatim}
To use the code make sure all python files are in your \verb!PYTHONPATH!,
note that numpy is required though this may change in the near future 
(and even sooner by request).

\section{Arguments}
  
\subsection{matrix}
  A numpy matrix or a nested list

\subsection{Filename}
  File to place output, extension .tex is added automatically. File can be included in a LaTeX
  document by \verb!\input{filename}!. If filename is None or not a string, output will be returned in a string
  
\subsection{*environments}
  Use 
\lstinline{matrix2latex(m, None, "align*", "pmatrix", ...)} for matrix.
  This will give
  \begin{align*}
    \begin{pmatrix}
      1 & 2 \\
      3 & 4
    \end{pmatrix}
  \end{align*}
  Use 
\lstinline{matrix2latex(m, "test", "table", "center", "tabular" ...)} for table.
  Table is default so given no arguments: table, center and tabular will be used.
  The above command is then equivalent to \\
\lstinline{matrix2latex(m, "test", ...)}

\subsubsection{Example}
\begin{sageblock}
  from matrix2latex import matrix2latex
  m = [[1, 2, 3], [1, 4, 9]] # python nested list
  t = matrix2latex(m)
  print t
\end{sageblock}
\begin{lstlisting}[language=tex, morekeywords={begin}]
  \begin{table}[ht]
    \begin{center}
      \begin{tabular}{cc}
        \toprule
        $1$ & $1$\\
        $2$ & $4$\\
        $3$ & $9$\\
        \bottomrule
      \end{tabular}
    \end{center}
  \end{table}
\end{lstlisting}
\sage{t}

\subsection{**keywords}
\subsubsection{rowLabels}
    A row at the top used to label the columns.
    Must be a list of strings.

Using the same example from above we can add row labels
\begin{sageblock}
rl = ['$x$', '$x^2$']
t = matrix2latex(m, rowLabels=rl)
\end{sageblock}
\sage{t}

\subsubsection{columnLabels}
    A column used to label the rows.
    Must be a list of strings

\subsubsection{transpose}
Flips the table around in case you messed up. Equivalent to
matrix2latex(m.H, ...)
if m is a numpy matrix.
Note the use of columnLabels in the example.
\begin{sageblock}
cl = ['$x$', '$x^2$']
t = matrix2latex(m, columnLabels=cl, transpose=True)
\end{sageblock}
\sage{t}

\subsubsection{caption}
    Use to define a caption for your table.
    Inserts \verb!\caption! after \verb!\end{tabular}!.
Always use informative captions!
\begin{sageblock}
t = matrix2latex(m, rowLabels=rl, 
                 caption='Nice table!')
\end{sageblock}
\sage{t}

\subsubsection{label}
Used to insert \verb!\label{tab:...}! after \verb!\end{tabular}!
Default is filename without extension.

We can use \lstinline{label='niceTable'} but if we save it to file
the default label is the filename, so:
\begin{sageblock}
matrix2latex(m, 'niceTable', rowLabels=rl, 
                 caption='Nice table!')
\end{sageblock}
can be referenced by \verb!\ref{tab:niceTable}!. Table \ref{tab:niceTable}
was included in latex by \verb!\input{niceTable}!.
\input{niceTable}

\subsubsection{format}
Printf syntax format, e.g. \lstinline{$%.2f$}. Default is \lstinline{$%g$}.
  This format is then used for all the elements in the table.
\begin{sageblock}
m = [[1, 2, 3], [1, 1/2, 1/3]]
rl = ['$x$', '$1/x$']
t = matrix2latex(m, rowLabels=rl,
                 format='%.2f')
\end{sageblock}
\sage{t}
  
\subsubsection{formatColumn}
A list of printf-syntax formats, e.g. \lstinline{[$%.2f$, $%g$]}
Must be of same length as the number of columns.
Format i is then used for column i.
This is useful if some of your data should be printed with more significant figures
than other parts
\begin{sageblock}
t = matrix2latex(m, rowLabels=rl,
                 formatColumn=['%g', '%.2f'])
\end{sageblock}
\sage{t}

\subsubsection{alignment}
Used as an option when tabular is given as enviroment.
\verb!\begin{tabular}{alignment}!
A latex alignment like c, l or r.
Can be given either as one per column e.g. ``ccc''.
Or if only a single character is given e.g. ``c'',
it will produce the correct amount depending on the number of columns.
Default is ``c'', if you use \lstinline{columnLabels} it will always use
``r'' as the alignment for that column.
\begin{sageblock}
m = [[1, 1/2, 1/3], [1, 1/2, 1/3]]
t = matrix2latex(m, alignment='rc')
\end{sageblock}
\sage{t}

But what if I want vertical rules in my table? Well, this package is built
on top of booktabs for publication ready tables and the booktabs documentation clearly
states ``Never, ever use vertical rule''. But as long as you are not publishing your table,
you could simply use
\begin{sageblock}
t = matrix2latex(m, alignment='|r||c|')
\end{sageblock}
\sage{t}

\subsubsection{General considerations}
Note that many of these options only has an effect when typesetting a table,
if the correct environment is not given the arguments are simply ignored.
To give an example of a very useless function call
\begin{sageblock}
t1 = matrix2latex(m, None, "align*", "pmatrix",
                 alignment='rc',
                 caption='hello world',
                 label='test')
# produces the exact same thing as
t2 = matrix2latex(m, None, "align*", "pmatrix")
assert t1 == t2
\end{sageblock}
\sage{t1}
The scary thing is that \lstinline{rowLabels} actually works when creating a matrix,
it just looks a bit wierd.

The options presented by this program represents what I need when creating a table,
if you need a more sophisticated table you must either change the python code
(feel free to submit a patch) or manually adjust the output afterwards.
\url{http://en.wikibooks.org/wiki/LaTeX/Tables} gives an excellent overview
of some advanced table techniques.

The booktabs.pdf documentation is an excellent guide to proper table creation,
matrix2latex does not incorporate all the features of this package (yet).
%Both caption and label will do nothing if tabular environment is not used.
% \begin{sagesilent}
% import sys
% sys.path.append('../')
% \end{sagesilent}
% \begin{sageblock}
% from matrix2latex import matrix2latex
% from numpy import matrix
% m = matrix("1 2 4;3 4 6") # numpy matrix or
% m = [[1, 2, 4], [3, 4, 6]] # python nested list
% matrix2latex(m, "test", "table", "center", "tabular", format="$%.2f$", alignment="lcr")
% # or since table, center and tabular is default:
% t = matrix2latex(m, format="$%.2f$", alignment="lcr")
% # produces:
% \end{sageblock}
% \sage{t}

\section{Usage examples}
The usefulness of a programming interface to create \LaTeX{}
tables becomes apparent when the data is dynamically created by python.
This can be either because you want flexibility with respect to the tables size
or because the table content is somehow created by python.

One day you decide to compare different implementations of the
factorial functions, you start by writing the following file
as \verb!factorial.py!
\lstinputlisting[lastline=20]{factorial.py}

The first thing to do is to verify that the three implementations actually give
the same results, for this we simply loop over the different functions and try for
different values of $n$. The result is shown in table \ref{tab:facV}.
\lstinputlisting[firstline=22, lastline=44]{factorial.py}
\input{facV}

What we really wanted to do was to
compare the speed of the different implementations. To do this
we use the python package timeit, the rest of the code is mostly unchanged.
\lstinputlisting[firstline=46]{factorial.py}
\input{facT}
%TODO: add simple real world example.
% \begin{table}[ht]
%   \begin{center}
%     \begin{tabular}{lcr}
%       $1.00$ & $2.00$ & $4.00$\\
%       $3.00$ & $4.00$ & $6.00$\\
%     \end{tabular}
%   \end{center}
% \end{table}


%\bibliographystyle{IEEEtran}
%\bibliography{doc}
\end{document}
